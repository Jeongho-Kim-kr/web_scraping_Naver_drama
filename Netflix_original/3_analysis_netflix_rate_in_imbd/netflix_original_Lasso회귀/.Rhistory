# Loading the library
library(glmnet)
# Loading the library
install.packages("glmnet")
library(glmnet)
# Loading the data
data(swiss)
force(swiss)
View(swiss)
x_vars <- model.matrix(Fertility~. , swiss)[,-1]
y_var <- swiss$Fertility
lambda_seq <- 10^seq(2, -2, by = -.1)
knitr::opts_chunk$set(echo = TRUE, comment=NA)
rm(list=ls())
library(readxl) # readxl 패키지로 엑셀을 읽을 수 있게 해줌
netflix <- read_excel('netflix_original_종합_수정(sum)_(정량화보함).xlsx') # 넷플릭스 오리지널 엑셀데이터를 읽어옴
netflix_original <- netflix
netflix_original <- netflix_original[,c(9,15,18,32:40)] # 엑셀에서 9,15,18 과 32~40번째 열을 가져오는 것.
netflix_original <- na.omit(netflix_original) # 어떤 결측치라도 있으면 행을 제거하고 남은 데이터를 반환
netflix_original[, 4:12] <- lapply(netflix_original[, 4:12], factor) # 위에서 뽑은 12개 열중 4~12열을 계산을 편하게 만들어주고 factor 형태로 만들어줌
netflix_original[, 1:3] <- lapply(netflix_original[, 1:3], as.numeric) # Mean_Length, Director_max_award, All_rating (1~3열) 항목을 숫자형으로 변환
netflix_drama <- netflix[1:170,]
netflix_drama <- netflix_drama[,c(9,15,18,32:40)]
netflix_drama <- na.omit(netflix_drama)
netflix_drama[, 4:12] <- lapply(netflix_drama[, 4:12], factor)
netflix_drama[, 1:3] <- lapply(netflix_drama[, 1:3], as.numeric)
netflix_movie <- netflix[171:589,]
netflix_movie <- netflix_movie[,c(9,15,18,32:40)]
netflix_movie <- na.omit(netflix_movie)
netflix_movie[, 4:12] <- lapply(netflix_movie[, 4:12], factor)
netflix_movie[, 1:3] <- lapply(netflix_movie[, 1:3], as.numeric)
x_vars <- model.matrix(Fertility~. , swiss)[,-1]
y_var <- swiss$Fertility
# Loading the library
install.packages("glmnet")
# Loading the library
library(glmnet)
# Loading the data
data(swiss)
x_vars <- model.matrix(Fertility~. , swiss)[,-1]
y_var <- swiss$Fertility
lambda_seq <- 10^seq(2, -2, by = -.1)
# Splitting the data into test and train
set.seed(86)
train = sample(1:nrow(x_vars), nrow(x_vars)/2)
x_test = (-train)
y_test = y_var[x_test]
cv_output <- cv.glmnet(x_vars[train,], y_var[train],
alpha = 1, lambda = lambda_seq,
nfolds = 5)
# identifying best lamda
best_lam <- cv_output$lambda.min
best_lam
View(netflix_original)
library(glmnet)
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
sh<-10^seq(10,-2,length=100)
ridge<-glmnet(x,y,alpha=0, lambda=sh)
dim(coef(ridge))
plot(ridge)
library(glmnet)
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
sh<-10^seq(10,-2,length=100)
ridge<-glmnet(x,y,alpha=0, lambda=sh)
dim(coef(ridge))
plot(ridge)
set.seed(1)
train<-sample(1:nrow(x),nrow(x)/2) #비복원 추출
test<-(-train)
y.test<-y[test]
ridge.tr<-glmnet(x[train,],y[train],alpha=0,lambda=sh,thresh=1e-12)
lm(y~x,subset=train)
library(glmnet)  # glmnet()
library(Metrics) # mse()
install.packages('Metrics')
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
model <- glmnet(x, y, alpha=1)
length(model$lambda)
coef(model)[, 1]     #  1번 모델의 회귀계수
coef(model)[,79]     # 79번 모델의 회귀계수
coef(model)[, 1]     #  1번 모델의 회귀계수
coef(model)[,94]     # 94번 모델의 회귀계수
pred <- predict(model, newx=x)
mse(y, pred[, 1])    #  1번 모델의 MSE
mse(y, pred[,94])    # 94번 모델의 MSE
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# lambda=1일 때
model1 <- glmnet(x, y, alpha=1, lambda=1)
coef(model1)
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# lambda 찾기
cv <- cv.glmnet(x, y, alpha=1)
cv$lambda.min # MSE 최소화 lambda = 0.8007036
cv$lambda.1se # MSE 최소화 lambda + 1 표준편차 = 1.535678
plot(cv)
rm(list=ls())
library(readxl) # readxl 패키지로 엑셀을 읽을 수 있게 해줌
netflix <- read_excel('netflix_original_종합_수정(sum)_(정량화보함).xlsx') # 넷플릭스 오리지널 엑셀데이터를 읽어옴
netflix_original <- netflix
netflix_original <- netflix_original[,c(9,15,18,32:40)] # 엑셀에서 9,15,18 과 32~40번째 열을 가져오는 것.
netflix_original <- na.omit(netflix_original) # 어떤 결측치라도 있으면 행을 제거하고 남은 데이터를 반환
netflix_original[, 4:12] <- lapply(netflix_original[, 4:12], factor) # 위에서 뽑은 12개 열중 4~12열을 계산을 편하게 만들어주고 factor 형태로 만들어줌
netflix_original[, 1:3] <- lapply(netflix_original[, 1:3], as.numeric) # Mean_Length, Director_max_award, All_rating (1~3열) 항목을 숫자형으로 변환
netflix_drama <- netflix[1:170,]
netflix_drama <- netflix_drama[,c(9,15,18,32:40)]
netflix_drama <- na.omit(netflix_drama)
netflix_drama[, 4:12] <- lapply(netflix_drama[, 4:12], factor)
netflix_drama[, 1:3] <- lapply(netflix_drama[, 1:3], as.numeric)
netflix_movie <- netflix[171:589,]
netflix_movie <- netflix_movie[,c(9,15,18,32:40)]
netflix_movie <- na.omit(netflix_movie)
netflix_movie[, 4:12] <- lapply(netflix_movie[, 4:12], factor)
netflix_movie[, 1:3] <- lapply(netflix_movie[, 1:3], as.numeric)
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# lambda 찾기
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
plot(fit1,xvar="lambda")
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
fit2<-glmnet(x,y,family="gaussian",alpha=1)
cv2<-cv.glmnet(x,y,family="gaussian",alpha=1)
cv2$lambda.min
plot(fit2,xvar="norm")
plot(cv2)
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
rm(list=ls())
library(readxl) # readxl 패키지로 엑셀을 읽을 수 있게 해줌
netflix <- read_excel('netflix_original_종합_수정(sum)_(정량화보함).xlsx') # 넷플릭스 오리지널 엑셀데이터를 읽어옴
netflix_original <- netflix
netflix_original <- netflix_original[,c(9,15,18,32:40)] # 엑셀에서 9,15,18 과 32~40번째 열을 가져오는 것.
netflix_original <- na.omit(netflix_original) # 어떤 결측치라도 있으면 행을 제거하고 남은 데이터를 반환
netflix_original[, 4:12] <- lapply(netflix_original[, 4:12], factor) # 위에서 뽑은 12개 열중 4~12열을 계산을 편하게 만들어주고 factor 형태로 만들어줌
netflix_original[, 1:3] <- lapply(netflix_original[, 1:3], as.numeric) # Mean_Length, Director_max_award, All_rating (1~3열) 항목을 숫자형으로 변환
netflix_drama <- netflix[1:170,]
netflix_drama <- netflix_drama[,c(9,15,18,32:40)]
netflix_drama <- na.omit(netflix_drama)
netflix_drama[, 4:12] <- lapply(netflix_drama[, 4:12], factor)
netflix_drama[, 1:3] <- lapply(netflix_drama[, 1:3], as.numeric)
netflix_movie <- netflix[171:589,]
netflix_movie <- netflix_movie[,c(9,15,18,32:40)]
netflix_movie <- na.omit(netflix_movie)
netflix_movie[, 4:12] <- lapply(netflix_movie[, 4:12], factor)
netflix_movie[, 1:3] <- lapply(netflix_movie[, 1:3], as.numeric)
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
# lambda에 따른 회귀계수의 크기 변화
plot(fit1,xvar="lambda")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
x<-model.matrix(All_rating~.,netflix_drama)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
# lambda에 따른 회귀계수의 크기 변화
plot(fit1,xvar="lambda")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
x<-model.matrix(All_rating~.,netflix_drama)[,-1] #-1은 절편 1제거
y<-netflix_drama$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
# lambda에 따른 회귀계수의 크기 변화
plot(fit1,xvar="lambda")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
x<-model.matrix(All_rating~.,netflix_movie)[,-1] #-1은 절편 1제거
y<-netflix_movie$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
# lambda에 따른 회귀계수의 크기 변화
plot(fit1,xvar="lambda")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
fit2<-glmnet(x,y,family="gaussian",alpha=1)
cv2<-cv.glmnet(x,y,family="gaussian",alpha=1)
cv2$lambda.min
# lambda에 따른 회귀계수의 크기 변화
plot(fit2,xvar="norm")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv2)
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
x<-model.matrix(All_rating~.,netflix_drama)[,-1] #-1은 절편 1제거
y<-netflix_drama$All_rating
fit2<-glmnet(x,y,family="gaussian",alpha=1)
cv2<-cv.glmnet(x,y,family="gaussian",alpha=1)
cv2$lambda.min
# lambda에 따른 회귀계수의 크기 변화
plot(fit2,xvar="norm")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv2)
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
x<-model.matrix(All_rating~.,netflix_movie)[,-1] #-1은 절편 1제거
y<-netflix_movie$All_rating
fit2<-glmnet(x,y,family="gaussian",alpha=1)
cv2<-cv.glmnet(x,y,family="gaussian",alpha=1)
cv2$lambda.min
# lambda에 따른 회귀계수의 크기 변화
plot(fit2,xvar="norm")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv2)
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
knitr::opts_chunk$set(echo = TRUE, comment=NA)
rm(list=ls())
library(readxl) # readxl 패키지로 엑셀을 읽을 수 있게 해줌
netflix <- read_excel('netflix_original_종합_수정(sum)_(정량화보함).xlsx') # 넷플릭스 오리지널 엑셀데이터를 읽어옴
netflix_original <- netflix
netflix_original <- netflix_original[,c(9,15,18,32:40)] # 엑셀에서 9,15,18 과 32~40번째 열을 가져오는 것.
netflix_original <- na.omit(netflix_original) # 어떤 결측치라도 있으면 행을 제거하고 남은 데이터를 반환
netflix_original[, 4:12] <- lapply(netflix_original[, 4:12], factor) # 위에서 뽑은 12개 열중 4~12열을 계산을 편하게 만들어주고 factor 형태로 만들어줌
netflix_original[, 1:3] <- lapply(netflix_original[, 1:3], as.numeric) # Mean_Length, Director_max_award, All_rating (1~3열) 항목을 숫자형으로 변환
netflix_drama <- netflix[1:170,]
netflix_drama <- netflix_drama[,c(9,15,18,32:40)]
netflix_drama <- na.omit(netflix_drama)
netflix_drama[, 4:12] <- lapply(netflix_drama[, 4:12], factor)
netflix_drama[, 1:3] <- lapply(netflix_drama[, 1:3], as.numeric)
netflix_movie <- netflix[171:589,]
netflix_movie <- netflix_movie[,c(9,15,18,32:40)]
netflix_movie <- na.omit(netflix_movie)
netflix_movie[, 4:12] <- lapply(netflix_movie[, 4:12], factor)
netflix_movie[, 1:3] <- lapply(netflix_movie[, 1:3], as.numeric)
library(glmnet)  # glmnet()
library(Metrics) # mse()
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
# lambda에 따른 회귀계수의 크기 변화
plot(fit1,xvar="lambda")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
ridge.pred
ridge.fit
coef
ridge.pred
x<-model.matrix(All_rating~.,netflix_drama)[,-1] #-1은 절편 1제거
y<-netflix_drama$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
x<-model.matrix(All_rating~.,netflix_drama)[,-1] #-1은 절편 1제거
y<-netflix_drama$All_rating
# 교차타당도가 가장 높은 lambda 때의 회귀계수값
fit1<-glmnet(x,y,family="gaussian",alpha=0)
cv1<-cv.glmnet(x,y,family="gaussian",alpha=0)
cv1$lambda.min
coef(cv1, s = "lambda.min")
# lambda에 따른 회귀계수의 크기 변화
plot(fit1,xvar="lambda")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv1)
ridge.fit <- glmnet(x, y, family="gaussian", alpha = 0, lambda = cv1$lambda.min)
coef(ridge.fit)
ridge.pred <- predict(ridge.fit, s = cv1$lambda.min, type = 'coefficients')
lasso.pred
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
x<-model.matrix(All_rating~.,netflix_original)[,-1] #-1은 절편 1제거
y<-netflix_original$All_rating
fit2<-glmnet(x,y,family="gaussian",alpha=1)
cv2<-cv.glmnet(x,y,family="gaussian",alpha=1)
cv2$lambda.min
# lambda에 따른 회귀계수의 크기 변화
plot(fit2,xvar="norm")
# lambda에 따른 회귀계수의 오차 변화
# 가로축: 벌점모수(lambda)에 자연로그를 취한 값, 세로축: 이탈도
plot(cv2)
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
lasso.pred
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
lasso.pred
lasso.pred
lasso.pred
lasso.pred
lasso.pred
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.fit<-glmnet(x,y,family="gaussian",alpha=1,lambda=cv2$lambda.min)
coef(lasso.fit)
lasso.pred <- predict(lasso.fit, s = cv2$lambda.min, type = 'coefficients')
knitr::opts_chunk$set(echo = TRUE, comment=NA)
?glmnet
